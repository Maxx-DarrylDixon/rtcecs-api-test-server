syntax = "proto3";
package tbadmin;

import "tbrpc/tbrpc.proto";
import "tbmatch/match.proto";


//
// ******************************* LUA Config Objects ***************************
//

message GlobalConfig {
	option (tbrpc.lua_config) = "Global";

	// Build version required by the server to login.
	// If blank, any build will be allowed.
	string req_build_version = 1;
}

message MatchQueueConfig {
	option (tbrpc.lua_config) = "MatchQueue";

	// Time to live for proposal keys in seconds.
	int32 proposal_ttl = 1;

	// Time to live for queue tickets.
	int32 queue_ticket_ttl = 2;

	// How many users to consider at once from top and bottom of time queue.
	int32 select_size = 3;

	// Control how much echelon may differ to qualify.
	double echelon_dist_min = 4;
	double echelon_dist_max = 5;
	double echelon_dist_per_sec = 6;
	double echelon_score_coeff = 7;
	double echelon_dist_normalized_min = 36;
	double echelon_dist_normalized_max = 37;

	// Control how much total rank points may differ to qualify.
	double point_dist_min = 8;
	double point_dist_max = 9;
	double point_dist_per_sec = 10;
	double point_score_coeff = 11;
	double point_dist_normalized_min = 38;
	double point_dist_normalized_max = 39;

	// How long to prevent 2 players from repeating the same match-up.
	double last_opp_exclude_time = 12;
	// How long to remember the last opponent.
	double last_opp_timeout = 13;

	// How long to wait before matching to a player on another continent.
	double cross_continent_exclude_time = 14;

	// Ping score minimum and increase with wait time.
	double ping_score_min = 15;
	double ping_score_max = 16;
	double ping_score_per_sec = 17;
	double ping_score_coeff = 18;
	double ping_score_normalized_min = 30;
	double ping_score_normalized_max = 31;

	// Geo distance minimum and increase with wait time.
	double geo_dist_min = 19;

	// 25,000km should be further than any possible distance between two points on earth
	double geo_dist_max = 20;
	// 200 km per second gets from LA to NY in 20 seconds, covers the world in 2 mins
	double geo_dist_per_sec = 21;
	double geo_score_coeff = 22;
	double geo_dist_normalized_min = 32;
	double geo_dist_normalized_max = 33;

	// Rating distance minimum and increase with wait time.
	double rating_dist_min = 23;
	double rating_dist_per_sec = 25;
	double rating_score_coeff = 26;
	double rating_dist_normalized_min = 34;
	double rating_dist_normalized_max = 35;

	// 0==normal, 1==in maintenance mode: no one enters queue, message about server maintenance
	int32 maintenance_mode = 28;

	// Time after which old active matches are forcibly removed.
	double active_match_timeout = 29;

	// How long to wait in the queue before timing out.
	int32 wait_timeout_sec = 40;

	// Unused - rating dist keeps climbing forever
	double __deprecated_rating_dist_max = 24;
}

message MatchUserConfig {
	option (tbrpc.lua_config) = "MatchUser";

	// Time to live for the ping table if we fail to clean up session.
	int32 ping_table_ttl = 1;

	// Time to live for the blacklist if we fail to clean up session.
	int32 blacklist_ttl = 2;
}

message LobbyConfig {
	option (tbrpc.lua_config) = "Lobby";

	// Max number of users to allow in a lobby.
	int32 max_members = 1;

	// Time-to-live for match keys generated by the lobby.
	int32 match_ttl = 2;

	// Time to live for lobby keys.
	int32 lobby_ttl = 3;

	// How long lobby matches remain in the active matches list if leaked.
	int32 active_match_timeout = 4;
}

message LogAggregatorConfig {
	option (tbrpc.lua_config) = "LogAggregator";

	// Time to live for log types in seconds.
	int32 match_log_ttl = 1;

	// Default time to live for unspecified log types
	int32 default_log_ttl = 20;
}



//
// ***************************** MatchConfig RPC Service ***************************
//

// Defines a client feature flag.
message FeatureDefinition {
	// Unique tag identifying the feature.  Cannot be empty or contain spaces.
	string tag = 1;

	// Free-form description of the feature.
	string description = 2;
}

// Describes when a set of feature flags are enabled.
message FeatureRule {
	// Server-generated unique ID of the rule.
	int64 rule_id = 1;

	// Feature tags and values enabled by the rule.
	tbmatch.ClientFeatureSet feature_set = 2;

	// Rule is only effective when enabled.
	bool enabled = 3;

	// Rules are evaluated in increasing priority order, with higher priority
	// rules taking precedence in case of conflict on a feature tag.
	int32 priority = 4;

	// Who owns this rule?
	string owner = 5;

	// Free-form text about this rule.
	string notes = 6;

	// If set, time after which the rule becomes active.
	int64 active_time_unix = 10;

	// If set, time after which the rule becomes inactive.
	int64 inactive_time_unix  = 11;
}

message GetGlobalConfigResult {
	GlobalConfig config = 1;
}
message SetGlobalConfigRequest {
	GlobalConfig config = 1;
}
message GetMatchQueueConfigResult {
	MatchQueueConfig config = 1;
}
message SetMatchQueueConfigRequest {
	MatchQueueConfig config = 1;
}
message GetMatchUserConfigResult {
	MatchUserConfig config = 1;
}
message SetMatchUserConfigRequest {
	MatchUserConfig config = 1;
}
message GetLobbyConfigResult {
	LobbyConfig config = 1;
}
message SetLobbyConfigRequest {
	LobbyConfig config = 1;
}


message ListFeatureDefinitionsResult {
	repeated FeatureDefinition def = 1;
}
message SetFeatureDefinitionRequest {
	FeatureDefinition def = 1;
}
message DeleteFeatureDefinitionRequest {
	string tag = 1;
}

message ListFeatureRulesResult {
	repeated FeatureRule rule = 1;
}
message GetActiveFeaturesResult {
	tbmatch.ClientFeatureSet feature_set = 1;
}
message CreateFeatureRuleRequest {
	FeatureRule rule = 1;
}
message UpdateFeatureRuleRequest {
	FeatureRule rule = 1;
}
message DeleteFeatureRuleRequest {
	int64 rule_id = 1;
}


service MatchConfigService {
	rpc GetGlobalConfig(tbrpc.Empty) returns (GetGlobalConfigResult) {
		option (tbrpc.access) = CONFIG_READ;
	}
	rpc SetGlobalConfig(SetGlobalConfigRequest) returns (tbrpc.Empty) {
		option (tbrpc.access) = CONFIG_WRITE;
	}
	rpc GetMatchQueueConfig(tbrpc.Empty) returns (GetMatchQueueConfigResult) {
		option (tbrpc.access) = CONFIG_READ;
	}
	rpc SetMatchQueueConfig(SetMatchQueueConfigRequest) returns (tbrpc.Empty) {
		option (tbrpc.access) = CONFIG_WRITE;
	}
	rpc GetMatchUserConfig(tbrpc.Empty) returns (GetMatchUserConfigResult) {
		option (tbrpc.access) = CONFIG_READ;
	}
	rpc SetMatchUserConfig(SetMatchUserConfigRequest) returns (tbrpc.Empty) {
		option (tbrpc.access) = CONFIG_WRITE;
	}
	rpc GetLobbyConfig(tbrpc.Empty) returns (GetLobbyConfigResult) {
		option (tbrpc.access) = CONFIG_READ;
	}
	rpc SetLobbyConfig(SetLobbyConfigRequest) returns (tbrpc.Empty) {
		option (tbrpc.access) = CONFIG_WRITE;
	}


	rpc ListFeatureDefinitions(tbrpc.Empty) returns (ListFeatureDefinitionsResult) {
		option (tbrpc.access) = CONFIG_READ;
	}
	// Create or update a feature definition.
	rpc SetFeatureDefinition(SetFeatureDefinitionRequest) returns (tbrpc.Empty) {
		option (tbrpc.access) = CONFIG_WRITE;
	}
	// Also deletes any feature rules referencing the feature.
	rpc DeleteFeatureDefinition(DeleteFeatureDefinitionRequest) returns (tbrpc.Empty) {
		option (tbrpc.access) = CONFIG_WRITE;
	}

	rpc ListFeatureRules(tbrpc.Empty) returns (ListFeatureRulesResult) {
		option (tbrpc.access) = CONFIG_READ;
	}
	rpc GetActiveFeatures(tbrpc.Empty) returns (GetActiveFeaturesResult) {
		option (tbrpc.access) = CONFIG_READ;
	}
	rpc CreateFeatureRule(CreateFeatureRuleRequest) returns (tbrpc.Empty) {
		option (tbrpc.access) = CONFIG_WRITE;
	}
	rpc UpdateFeatureRule(UpdateFeatureRuleRequest) returns (tbrpc.Empty) {
		option (tbrpc.access) = CONFIG_WRITE;
	}
	rpc DeleteFeatureRule(DeleteFeatureRuleRequest) returns (tbrpc.Empty) {
		option (tbrpc.access) = CONFIG_WRITE;
	}
}




//
// ***************************  TBMatch instance: ServerConfig  ************************
//
// ServerConfig configures a local TBMatch instance, and is typically stored as a file
// read by tbmatch on startup.  It contains:
//    - Network host names, port numbers for connecting to dependent services
//    - Credentials for authorizing to dependent services
//    - Local paths for finding support data files, templates, keys
//    - Port and path where TBMatch should accept requests.
//

// How to connect to the database.
message DatabaseConfig {
	string user = 1;
	string password = 2;
	string host = 3;
	int32 port = 4;
	string database = 5;

	// How long to wait for a connection to establish in seconds.
	// Zero means infinite.
	int32 connect_timeout = 6;

	// Max number of idle connections.
	int32 max_idle = 7;

	// Max open connections.
	int32 max_open = 8;

	// "disable", "require", or "verify-full"
	string ssl_mode = 9;

	string schema_path = 20;
}

message RedisConfig {
	string host = 1;
	int32 port = 2;
	string password = 3;

	int32 max_idle = 4;

	// Switch to a non-default database index.
	int32 database = 5;

	// How long to wait for a new Redis connection in milliseconds.
	int32 connect_timeout_ms = 10;

	// Read timeout in milliseconds.  0 = infinite.
	int32 read_timeout_ms = 11;
	int32 write_timeout_ms = 12;

	// Path containing Lua script files to load in Redis.
	string lua_path = 13;

	// Extra Lua include search paths.
	repeated string lua_include = 14;
}

// Generic Google API access credentials
message GApiConfig {
	string proxy_url = 1;
	string project_id = 2;

	enum AuthType {
		AUTH_TYPE_ZERO = 0;
		GCE = 1;
		SDK = 2;
	}
	AuthType auth = 4;

	// role account for auth == GCE
	string gce_account = 10;

	// account name for auth == SDK
	string sdk_account = 11;
}

// Where to store something on Google Cloud Storage.
message GcsStorageConfig {
	string proxy_url = 1;
	string project_id = 2;
	string bucket_name = 3;
}

message SessionAuthKey {
	// Base64 encoded session key for signing new cookies.
	string current = 1;
	// Base64 encoded alternate encoded key signature to accept.
	string previous = 2;
}

// How to expose RPC methods.
message RPCConfig {
	// HTTP port to bind to.
	int32 http_port = 1;

	// URI prefix to expose the tbmatch API.
	string rpc_uri = 2;

	// The 64-byte session key.
	SessionAuthKey session_key = 3;

	// How long before an idle session is discarded with no activity at all.
	int32 session_timeout_secs = 4;

	// Time window to consider "active" sessions, e.g. those invoking methods
	// other than GetEvent.
	int32 session_active_window_secs = 5;

	// Max content size of requests, to prevent denial of service
	int64 max_request_size = 6;

	// File to log JSON-format RPC records.
	string json_log_path = 10;
}

// Configuration for talking to payment gateway (Authorize.Net).
message PaymentCreds {
	// URL where the API can be reached.
	string api_url = 1;

	// API Login ID.
	string api_login_id = 2;

	// Transaction Key.
	string transaction_key = 3;
}

// How to talk to the Portal service via Redis.
message PortalClientConfig {
	// List to enqueue (RPUSH) portal requests.
	string request_queue = 1;

	// List to consume (BLPOP) portal closure reports.
	string report_queue = 2;

	// Time to wait for response from a portal request.
	int32 response_timeout_ms = 3;
}

message MonitorConfig {
	// URI to access export variables.
	string vars_uri = 1;

	string health_uri = 2;

	// List of allowed subnets in CIDR notation for vars_uri, desyncz_uri, appconfz_uri
	// No entries allows access from any host.
	repeated string vars_allow_net = 3;

	// Separate allowed subnets for health_uri.
	repeated string health_allow_net = 4;

	// Where to serve the loaded appconfig.  Empty means don't serve.
	string appconfz_uri = 21;
}

// Common mail template variables.
message MailGlobalVars {
	string sender_address = 1;
	string site_name = 2;
	string sender_name = 4;

	string account_recovery_url = 3;
}

message MailConfig {
	// SMTP hosts to connect to.
	message MailHost {
		string host = 1;
		int32 port = 2;
	}
	repeated MailHost host = 1;

	bool tls = 3;
	bool insecure_skip_verify = 4;


	// Login credentials.
	string auth_user = 5;
	string auth_password = 6;

	// Location of mail fragments and templates.
	string template_path = 7;
	string include_path = 8;
	// Check for changes on disk when fetching a template.
	bool auto_reload = 9;

	MailGlobalVars vars = 20;
}

message MatchMakerConfig {
	// Participate in election and poll queues when master?
	bool enabled = 1;

	// How often to try to become master when not.
	int32 master_retry_interval_ms = 2;

	// Milliseconds after which the master lock should expire if not re-upped.
	int32 master_lock_expiry_ms = 3;

	// How often to run the polling script as master.
	int32 poll_period_ms = 4;

	// If the polling script fails, how long to back off.
	int32 error_retry_ms = 5;
}

message AdminServerConfig {
	// Periodically look for history records in BQ and remove them from PostGres.
	// Behavior is configured through ExportTrimConfig within AppConfig.
	bool enable_export_trim = 1;
}

//
// Server run-time config file.  Tells this server how to launch
// and resolve service dependencies.  May contain some credentials.
//
message ServerConfig {
	DatabaseConfig db_config = 1;
	RPCConfig rpc_config = 2;
	RedisConfig redis_config = 3;
	MailConfig mail = 4;
	PaymentCreds payment_creds = 5;
	PortalClientConfig portal_client = 6;
	MatchMakerConfig match_maker = 7;

	MonitorConfig monitor_config = 10;

	GcsStorageConfig desync_storage = 11;
	GcsStorageConfig crash_storage = 12;
	string stackwalk_binary_path = 13;
	GcsStorageConfig match_log_storage = 14;

	string geolite_database_file = 20;

	// How to reach and authenticate to all Google APIs.
	GApiConfig google = 30;

	string bigquery_dataset = 31;
	string bigquery_prefix = 32;

	// Number of cores Go runtime should use.
	int32 go_max_procs = 40;

	bool portal_sim_enabled = 61;


	// Enable admin RPC services.
	bool admin_server = 70;
	AdminServerConfig admin_server_config = 71;
}


//
// ***************************  TBMatch shared: AppConfig  ************************
//
// AppConfig is stored in the database, and provides configuration options that:
//    - Do not have security concerns.
//    - Are common to all TBMatch instances in a deployment.
//    - Define global application behaviors or reference data.
//

// Rules for handling account RPCs.
message AccountConfig {
	// Minimum length when setting a password.
	int32 min_password_length = 1;

	// Minimum number of unique character classes for a password.
	int32 min_password_classes = 2;

	// Access roles granted to publicly registered accounts.
	repeated tbrpc.Access register_access = 3;

	// How long before e-mail validation links expire.
	int32 email_validate_confirm_secs = 4;

	// Prepended to email validation links.
	string email_validate_url_prefix = 5;

	// Number of bytes in the generated nonce hex string.
	int32 validate_nonce_length = 6;

	// How long a password reset code is valid for in seconds.
	int32 password_reset_expire_secs = 7;

	// Number of letters and numbers in the reset code.
	int32 password_reset_code_length = 8;

	// Max number of users to return from SearchUsers.
	int32 max_user_search_result = 10;

	// Minutes to keep an account locked out after exceeding lockout_threshold attempts.
	int32 lockout_duration_mins = 20;

	// Number of failed login attempts before account is locked.
	// Set to 0 to disable lockout.
	int32 lockout_threshold = 21;

	// Number of minutes after the last login failure after which the counter is reset to 0.
	int32 reset_lockout_counter_after_mins = 22;

	// How long do session tickets last (SessionService.RequestSessionTicket)?
	int32 session_ticket_expire_secs = 30;

	// Require a registration key?
	bool require_registration_key = 40;

	// Deny any handle that full-matches one of these expressions.
	repeated string disallow_handle_regexp = 41;

	// Prefix to use when generating a handle to replace an offensive/disallowed one.
  	string nuke_handle_prefix = 42;

	// Pre-existing nuked handles to skip over before giving up.
	int32 nuke_retries = 43;
}


// How an experience counter maps to increasing "levels".
// Level 1 starts at 0 XP.
message LevelProgression {
	// How much XP is required to reach level 2 from level 1.
	int32 baseline = 1;

	// A level takes this much more XP to reach than the previous level.
	double coefficient = 2;

	// XP awarded for playing a match.
	int32 match_xp = 3;

	// XP awarded for winning a match.
	int32 win_bonus_xp = 4;
}

message EchelonRules {
	// Points required to advance for each tier in this echelon.
	repeated int32 tier_points = 1;

	// If true, don't apply losses while in this echelon.
	bool ignore_loss = 2;

	// If true, echelon has no tiers or points.
	bool final = 3;
}

message EchelonConfig {
	// Define all ranking echelons in progression order (0=Carbon .. N-1=Legend)
	repeated EchelonRules echelon = 1;

	// Number of wins in a streak for bonus to apply.
	int32 win_streak_bonus_minimum = 10;

	// Points to award for a win streak bonus.
	int32 win_streak_bonus_points = 11;
}

message RankConfig {
	LevelProgression player_progress = 1;
	LevelProgression char_progress = 2;

	// Define the ranking echelons.
	EchelonConfig echelon_config = 3;
}

message Glicko2RatingConfig {
	// How deterministic are matches in this game (0.2 .. 1.2)
	float tau = 1;

	// How many minutes in each rating period?
	int32 rating_period_mins = 2;

	// How often should MatchMaker master check for new matches to rate?
	int32 check_period_mins = 3;

	// Rating deviation (RD) for an unrated (or maximum lapsed) player.
	float max_deviation = 10;

	// Rating deviation (RD) never to drop below, to ensure some freedom of movement.
	float min_deviation = 11;

	// Number of rating periods must pass before an active player's deviation
	// becomes as uncertain as that of an unrated player.
	// Determines 'c' in Glicko paper.  Default (for 30 minute period) is 3 weeks.
	float deviation_decay_periods = 12;

	// Rating deviation of a "typical" active player for computation of 'c'.
	float typical_deviation = 13;
}

// Behaviors of the Matching methods.
message MatchServiceConfig {
	// How long to wait for an opponent to be ready to continue a match.
	int32 match_ready_timeout_ms = 2;

	// How to award players with the outcome of a match.
	RankConfig rank = 7;

	// Max recent match results to return from GetRecentMatches.
	int32 max_recent_results = 8;

	// If we lost more than this percentage of packets during ping test,
	// advise the user of network issues and don't record the result for matchmaking.
	float max_packet_loss_ratio = 21;

	// Max number of seconds between each player's desync report to qualify.
	int32 desync_report_max_drift = 30;

	// How to perform perform Glicko2 rating system updates.
	Glicko2RatingConfig rating_config = 50;

	// Glicko rating to assign to players with zero games played.  Glicko
	// ratings still assume 1500.
	float unrated_glicko_rating = 60;

	// Glicko rating to assign to players with zero games played depending
	// on their SkillEstimateType. SkillEstimateType acts as the index into
	// the array.
	repeated float default_glicko_rating = 61;

	// Max portion of rating difference to adjust for win/loss, scaled by deviation.
	float session_rating_adjust_coefficient = 65;

	// How long, in seconds, to re-use the last read values from lua config objects.
	int32 lua_config_cache_sec = 70;

	// Require that only one game may be played at once, only one random match queue
	// can be pending at a time, and cannot enqueue while in a custom lobby.
	bool strict_game_sessions = 80;

	// deprecated
	int32 __deprecated_get_ranked_timeout_ms = 1; // moved to lua config
	bool __deprecated_provide_local_fsm = 3;
	string __deprecated_replay_path = 4;
	int32 __deprecated_match_lifetime_sec = 6; // moved to lua config
	int32 __deprecated_select_size = 9;		// moved to lua config
	string __deprecated_desync_report_path = 5;
	int32 __ping_test_lifetime_sec = 20;
	int32 __deprecated_games_to_win = 40;
}

message LobbyServiceConfig {
	// Number of characters in the join code.
	int32 join_code_length = 1;

	// Maximum number of members allowed in a single lobby.
	int32 max_members = 2;
}

// How to interact with Authorize.Net API.
message PaymentConfig {
	// Amount of time to wait for calls before giving up.
	int32 timeout_ms = 1;

	// An Authorize.Net account works in a single currency type
	// that is associated with the merchant account.  Use this currency
	// to format and verify input amounts.  If none is given, uses
	// the default system currency in AppConfig.
	string currency = 2;

	// Whether to use transactionSettings/testRequest=TRUE.
	// This is for phase 2 testing, connecting to the production API endpoint,
	// but still submitting test requests.
	bool test_mode = 3              ;

	// How to perform validation of payment profiles on
	// creation and update.  Maps to validationMode parameter
	// of the CIM API.  TEST and LIVE will generate e-mails, but
	// only LIVE will reach the payment processor.
	enum Validation {
		VALIDATION_ZERO = 0;
		NONE = 1;
		TEST = 2;
		LIVE = 3;
	}
	Validation val_mode = 4;

	// Character delimiting fields in APIs that return a "direct response".
	// Authorize.Net sets this to comma by default, but we choose pipe and
	// disallow pipe in most fields.
	string direct_response_delimiter = 5;
}

// Describes a supported currency and rules for working with it.
message CurrencyDesc {
	// 3-letter capital code.
	string code = 1;

	// Digits of precision.
	int32 precision = 2;

	// Character prepended to distinguish values.
	string symbol = 3;

	// List of 3-letter country codes that use this currency.
	repeated string country_iso3 = 4;

	// Allow balance loads with this currency.
	bool balance_purchase_allow = 40;

	// Default values given for account balance purchases.
	repeated tbrpc.Money balance_purchase_default = 41;

	// Range of allowed custom balance purchase amounts.
	tbrpc.Money balance_purchase_min = 42;
	tbrpc.Money balance_purchase_max = 43;

	// Maximum balance an account may hold in this currency.
	// Orders that would exceed this amount are rejected.
	tbrpc.Money balance_max = 50;
}

// What currencies are supported and their rules.
message CurrencyConfig {
	repeated CurrencyDesc desc = 1;

	// Currency to use for new accounts when the country code
	// is unknown.
	string default_currency = 2;
}

// Configuration for online store behaviors, limits, etc.
message ShopConfig {
	PaymentConfig payment = 1;
	CurrencyConfig currency = 2;

	// Max number of orders to return from SearchPurchaseOrders.
	int32 max_order_search_result = 10;

	// Max number of results returned from GetAccountOrderHistory.
	int32 order_history_page_size = 11;

	// Max number of days you can view balance history over.
	int32 max_balance_history_days = 12;
}

message EventConfig {
	// Milliseconds that RPCs waiting on changes are
	// allowed to wait before giving up.
	int32 change_wait_timeout_ms = 10;

	// Default lifetime of time-limited events.
	int32 event_expiry_ms = 11;

	// Default lifetime of user event queue keys themselves.
	int32 user_key_expiry_sec = 12;
}

message AuditConfig {
	// Most number of results to return from an audit query.
	int32 max_audit_search_result = 1;

	// Largest time range allowed for a search.
	int32 max_audit_search_days = 2;
}

message CrashReportConfig {
	bool should_store_crash_bundles = 1;
	int32 max_versions_to_keep = 2;		// the number of build versions for each client app to keep the crash redis records around for
	int32 polling_interval = 3;		// the interval to check for new crash reports to symbolicate, in seconds
}

// Flags to provide (mainly) backwards compatibility during server rollouts.
message ServerRolloutFlags {

	// Provide hashing secret for clients, and check signatures of
	// incoming UDP packets.
	bool secure_portal_udp_traffic = 2;

	// Search for a ticket to get back into queue at an old spot
	// even when using the GetMatch rpc.
	// Purpose: backwards compatibility while waiting for client
	//          build to use ResumeGetMatch for auto-requeueing
	bool __deprecated_auto_resume_get_match = 1;
}

message DesyncReportConfig {
	int32 polling_interval = 3;		// the interval to check for new desync reports to process, in seconds
}

// Configuration for trimming database history tables which are accumulated externally.
message ExportTrimConfig {
	// Whether database table trimming is enabled.
	bool trim_enabled = 1;

	// Don't look for records younger than this age.
	int32 min_age_days = 2;

	// Process at most this many records at once.
	int32 batch_size = 3;

	// How often to trim the database.
	int32 trim_interval_mins = 4;
}

//
// AppConfig contains application reference data and behavioral settings.
// It is stored in the database and is applied universally by all servers.
//
// It should NOT contain highly sensitive information such as credentials
// or key material.
//
message AppConfig {
	AccountConfig account_config = 1;
	MatchServiceConfig match_config = 2;
	ShopConfig shop_config = 3;
	EventConfig event_config = 4;
	AuditConfig audit_config = 5;
	LobbyServiceConfig lobby_config = 6;
	CrashReportConfig crash_report_config = 7;
	ServerRolloutFlags server_rollout_flags = 8;
	DesyncReportConfig desync_report_config = 9;
	ExportTrimConfig export_trim_config = 10;
}

// Allow frontend and other servers to read AppConfig.
service ConfigService {
	rpc GetAppConfig (tbrpc.Empty) returns (AppConfig) {
		option (tbrpc.access) = APP;
	}
}



//
// ***************************** TBFE config file: FEConfig  ****************************
//
// FEConfig is TBFE's stored local configuration file.  It tells a TBFE on
// startup where to connect to dependent services, and contains sensitive secrets and
// credentials.
//

message FEContentConfig {
	// Directory containing templates and data files.
	string data_dir = 1;

	// Root for static web content (optional).
	string static_dir = 2;

	// If enabled, reload templates on every request.
	bool devel_mode = 3;

	// Directory where localization resources can be found.
	// tb.properties must be present here.
	string message_dir = 4;

	// Name of the application.
	string application_name = 5;

	string recaptcha_site_key = 6;
	string recaptcha_secret_key = 7;
	string recaptcha_verify_url = 8;

	// HTTP(s) proxy to use when querying the recaptcha URL.
	string recaptcha_proxy_url = 9;

	// After how many form submission failures should you have to solve another CAPTCHA?
	int32 recaptcha_failure_threshold = 10;

	// If set, send 301 redirect requests NOT using this host name.
	string canonical_hostname = 11;

	// URL scheme to use when redirecting to canonical_hostname.
	string canonical_scheme = 12;

	// Template to use for content of a 503 Internal Server Error.
	string internal_error_template = 20;

	// Template for 404 not found page content.
	string not_found_template = 21;

	// Path to redirect to when an authorized-only page is
	// requested with no valid session.
	string login_redirect_path = 22;

	// Link to download the launcher for logged-in users.
	string launcher_download_url = 30;

	// Link to the forum.
	string forum_url = 31;

	// If set, redirect requests to the landing page to here.
	string landing_redirect_url = 40;
}

message FEBackendConfig {
	// Where to reach Match API servers.
	tbrpc.LBClientConfig match_client = 1;

	// Backend account to use for fetching application metadata.
	string app_login = 2;
	string app_password = 3;

	// How long to wait for readyness on startup.
	int32 startup_wait_sec = 10;
}

message VanillaJSConnectConfig {
	string client_id = 1;
	string secret = 2;
	int32 max_age_secs = 3;

	// Role for users with 0 forum access otherwise.
	string unauth_role	= 4;

	// Email suffix that enables the "blessed" role
	string bless_email_suffix = 10;
	// Role that is bestowed
	string bless_role = 11;
}

//
// Run-time file for the tbfe web application server.
//
message FEConfig {
	// Port to listen on for HTTP requests.
	int32 http_port = 1;

	// Session key(s) to use.
	SessionAuthKey session_key = 2;

	// Number of seconds after which idle sessions will
	// expire.
	int32 session_timeout_secs = 3;

	// Number of cores Go runtime should use.
	int32 go_max_procs = 4;

	// Where to write access records in JSON format.
	string json_access_log_path = 5;

	// Monitoring configuration.
	MonitorConfig monitor_config = 10;

	// How to talk to Redis for sessions.
	RedisConfig redis_config = 60;

	// Where to find and how to serve dynamic HTML content.
	FEContentConfig content_config = 61;

	// Where to reach backend API servers.
	FEBackendConfig backend_config = 62;

	VanillaJSConnectConfig vanilla = 70;
}


//
// ************************** MatchMon config file: MatchMonConfig *********************
//
// MatchMonConfig is the local config file for MatchMon, the internal admin console
// for TBMatch services.
//

message MatchMonConfig {
	// Port to listen on for HTTP requests.
	int32 http_port = 1;

	// Directory containing templates and include files.
	string data_dir = 3;
	// Directory containing static content.
	string static_dir = 4;

	// Where to find GeoIP.dat
	string geoip_dir = 6;

	// Where to load localization resources.
	string msg_dir = 7;

	// Where to persist sessions.
	string session_dir = 8;

	// Where desyncs are stored.
	GcsStorageConfig desync_storage = 11;

	// Where crash information is stored.
	GcsStorageConfig crash_storage = 12;

	// Where to reach backend API servers.
	FEBackendConfig backend_config = 13;

	// How often to run statistical queries in seconds.
	int32 poll_interval_sec = 21;

	// Time cut-off for considering a session active.
	int32 session_count_max_age_sec = 31;
	// Max # of results to pull from the recent session table.
	int32 session_result_limit = 32;

	// Max # of lobbies to pull from active lobbies.
	int32 lobby_result_limit = 41;

	// Max # of active matches to retrieve.
	int32 active_match_result_limit = 42;
}
