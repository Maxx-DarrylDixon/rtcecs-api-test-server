syntax = "proto3";
package tbmatch;

import "tbrpc/tbrpc.proto";
import "tbmatch/match.proto";

// ********************* Enum Types ************************

enum LobbyType {
	LOBBY_TYPE_ZERO = 0;
	LT_QUEUED = 1;
}

enum LobbyState {
	LOBBY_STATE_ZERO = 0;
	// Waiting for 2 ready players.
	LS_IDLE = 1;

	// Match is ready to start.
	LS_MATCH_PENDING = 2;

	// A match is in progress.
	LS_MATCH = 3;
}


// ******************* Lobby Message Types **********************

message LobbyMember {
	int64 account_id = 1;
	string handle = 2;

	// Lobby owner?
	bool owner = 10;

	// Ready for next match?
	bool ready = 11;
}


message Lobby {
	// Unique identifier for this lobby.
	int64 lobby_id = 1;

	// Style of gameplay conducted in the lobby.
	LobbyType type = 2;

	// Name given by creator.
	string name = 3;

	// Current state of the lobby.
	// Updated by LobbyStatusEvent.
	LobbyState state = 5;

	// People currently in the lobby.
	// Updated by LobbyMemberUpdateEvent.
	repeated LobbyMember member = 10;

	// Options included for the next match generated by this lobby.
	GameOptions options = 11;

	// For state == LS_MATCH, start config of the game being played.
	GameConfig game_config = 20;

	// For type == LT_QUEUED, this is the current queue order of account IDs.
	// Updated by LobbyMemberUpdateEvent.
	repeated int64 queue = 30;
}



// ******************* RPC Request / Response types ********************

message CreateLobbyRequest {
	LobbyType type = 1;
	string name = 2;
}


message GetLobbyJoinCodeRequest {
	int64 lobby_id = 1;
}
message GetLobbyJoinCodeResult {
	string join_code = 1;
}


message JoinLobbyByCodeRequest {
	string code = 1;
}


message LobbySetReadyRequest {
	bool ready = 2;

	// If ready == true, layer network and character data for the next match.
	NetworkAddr network = 10;
	CharacterSpec character = 11;
}

message LobbySetGameOptionsRequest {
	// Any set fields will be updated in the lobby GameConfig template.
	GameOptions options = 1;
}

message LobbySetOwnerRequest {
	int64 lobby_id = 1;
	int64 account_id = 2;
	bool set_owner = 3;
}


message LobbyBanUserRequest {
	int64 lobby_id = 1;
	int64 account_id = 2;
}

message LobbyRemoveUserRequest {
	// ID of the lobby.
	int64 lobby_id = 1;
	// Account ID of the user to kick.
	int64 account_id = 2;
}


service LobbyService {
	// Create a new lobby and join it, with the creator as owner.
	// Fails if user is already in a lobby.
	// Success confirmed by LobbyJoin event.
	rpc CreateLobby (CreateLobbyRequest) returns (tbrpc.Empty) {
		option (tbrpc.session) = GAME_RT;
		option (tbrpc.access) = MATCH;
	}

	// Get the secret code for joining this lobby.  Only members marked as
	// owner may request the code.
	rpc GetLobbyJoinCode (GetLobbyJoinCodeRequest) returns (GetLobbyJoinCodeResult) {
		option (tbrpc.session) = GAME_RT;
		option (tbrpc.access) = MATCH;
	}

	// Join a lobby using a secret code provided by a lobby owner.
	// Fail if user is already joined to another lobby.  Success confirmed by LobbyJoin event.
	rpc JoinLobbyByCode (JoinLobbyByCodeRequest) returns (tbrpc.Empty) {
		option (tbrpc.session) = GAME_RT;
		option (tbrpc.access) = MATCH;
	}

	// Leave the currently joined lobby.  If the player is the last owner, another
	// owner is assigned at random.  If player is last member, lobby is destroyed.
	// Success confirmed by LobbyLeave event.
	rpc LeaveLobby (tbrpc.Empty) returns (tbrpc.Empty) {
		option (tbrpc.session) = GAME_RT;
		option (tbrpc.access) = MATCH;
	}

	// Set ourselves ready or not-ready for a match in the joined lobby if the lobby state allows it.
	rpc LobbySetReady (LobbySetReadyRequest) returns (tbrpc.Empty) {
		option (tbrpc.session) = GAME_RT;
		option (tbrpc.access) = MATCH;
	}

	// Grant or revoke owner status to another member of the lobby -- owner only.
	rpc LobbySetOwner (LobbySetOwnerRequest) returns (tbrpc.Empty) {
		option (tbrpc.session) = GAME_RT;
		option (tbrpc.access) = MATCH;
	}

	// Set the global options for matches generated by this lobby -- owner only.
	rpc LobbySetGameOptions (LobbySetGameOptionsRequest) returns (tbrpc.Empty) {
		option (tbrpc.session) = GAME_RT;
		option (tbrpc.access) = MATCH;
	}

	// Remove a user from the lobby and permanently restrict them from re-entering.
	rpc LobbyBanUser (LobbyBanUserRequest) returns (tbrpc.Empty) {
		option (tbrpc.session) = GAME_RT;
		option (tbrpc.access) = MATCH;
	}

	// Remove a user from the lobby.
	rpc LobbyRemoveUser (LobbyRemoveUserRequest) returns (tbrpc.Empty) {
		option (tbrpc.session) = GAME_RT;
		option (tbrpc.access) = MATCH;
	}
}
